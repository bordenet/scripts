#!/bin/bash

# This script sets up a secure sandbox environment for inspecting potentially malicious files.
# PKI assets are stored in .env as the single source of truth and are NEVER committed to git.

# --- Configuration ---
SANDBOX_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
SHARED_DIR="${SANDBOX_DIR}/shared"
VM_NAME="inspection-sandbox"
ENV_FILE="${SANDBOX_DIR}/.env"
# Alpine Linux latest stable version (check https://alpinelinux.org/downloads/ for updates)
ALPINE_VERSION="3.22.1"
ALPINE_ISO_URL="https://dl-cdn.alpinelinux.org/alpine/v${ALPINE_VERSION%.*}/releases/x86_64/alpine-virt-${ALPINE_VERSION}-x86_64.iso"

# --- Functions ---

#
# Checks for required dependencies.
#
check_dependencies() {
    echo "Checking for dependencies..."
    local missing_deps=0

    # Check for Homebrew
    if ! command -v brew &>/dev/null; then
        echo "Error: Homebrew is not installed. Please install it from https://brew.sh/"
        missing_deps=$((missing_deps + 1))
    fi

    # Check for UTM
    if ! command -v utmctl &>/dev/null; then
        echo "Error: UTM is not installed. Please install it via 'brew install --cask utm'"
        missing_deps=$((missing_deps + 1))
    fi

    if [ "$missing_deps" -ne 0 ]; then
        echo "Please install the missing dependencies and run the script again."
        exit 1
    fi
    echo "All dependencies are installed."
}

#
# Creates the required directories.
#
create_directories() {
    echo "Creating directories..."
    mkdir -p "${SHARED_DIR}"
    echo "Directories created."
}

#
# Downloads the Alpine Linux ISO (virt edition for VM support).
#
download_iso() {
    echo "Downloading Alpine Linux ISO (virt edition)..."
    if [ ! -f "${SANDBOX_DIR}/alpine.iso" ]; then
        curl -L -o "${SANDBOX_DIR}/alpine.iso" "${ALPINE_ISO_URL}"
    else
        echo "Alpine Linux ISO already downloaded."
    fi
    echo "Alpine Linux ISO ready."
}

#
# Initializes .env file with configuration if it doesn't exist.
#
init_env_file() {
    if [ ! -f "${ENV_FILE}" ]; then
        echo "Creating .env file..."
        cat > "${ENV_FILE}" << 'EOF'
# Malware Inspection Sandbox - Environment Variables
# This file stores sensitive keys and configuration
# IMPORTANT: This file is in .gitignore and will NOT be committed

# =============================================================================
# SSH Keys (Base64 Encoded - Single Source of Truth)
# =============================================================================
# These keys are generated by setup_sandbox.sh and stored here
# Scripts will extract these to temporary runtime files when needed
# NEVER commit these keys to git!

SSH_PRIVATE_KEY_B64=""
SSH_PUBLIC_KEY=""

# =============================================================================
# VM Configuration
# =============================================================================
VM_NAME=inspection-sandbox
VM_IP=192.168.64.2
VM_SSH_PORT=2222
VM_USER=root

# =============================================================================
# Paths and Directories
# =============================================================================
SHARED_DIR=./shared
ALPINE_ISO=./alpine.iso
ALPINE_VERSION=3.22.1
ALPINE_ISO_URL=https://dl-cdn.alpinelinux.org/alpine/v3.22/releases/x86_64/alpine-virt-3.22.1-x86_64.iso
EOF
        echo ".env file created."
    fi
}

#
# Generates an SSH key pair and stores it in .env.
# IMPORTANT: Keys are NEVER stored as files in git - only in .env (which is gitignored)
#
generate_ssh_key() {
    echo "Checking for SSH key pair..."

    # Check if keys exist in .env
    if [ -f "${ENV_FILE}" ]; then
        source "${ENV_FILE}"
        if [ -n "$SSH_PRIVATE_KEY_B64" ] && [ -n "$SSH_PUBLIC_KEY" ]; then
            echo "SSH keys found in .env, extracting to temporary files..."
            # Extract private key from .env
            echo "$SSH_PRIVATE_KEY_B64" | base64 -d > "${SANDBOX_DIR}/id_rsa"
            chmod 600 "${SANDBOX_DIR}/id_rsa"
            # Extract public key from .env
            echo "$SSH_PUBLIC_KEY" > "${SANDBOX_DIR}/id_rsa.pub"
            chmod 644 "${SANDBOX_DIR}/id_rsa.pub"
            # Copy public key to shared folder
            cp "${SANDBOX_DIR}/id_rsa.pub" "${SHARED_DIR}/id_rsa.pub"
            echo "SSH keys extracted from .env."
            return 0
        fi
    fi

    # Keys don't exist, generate new ones
    echo "Generating new SSH key pair..."
    ssh-keygen -t rsa -b 4096 -f "${SANDBOX_DIR}/id_rsa" -N ""

    # Store keys in .env (Base64 encode private key)
    echo "Storing SSH keys in .env..."
    local private_key_b64=$(base64 -i "${SANDBOX_DIR}/id_rsa" | tr -d '\n')
    local public_key=$(cat "${SANDBOX_DIR}/id_rsa.pub")

    # Update .env with keys
    if [ -f "${ENV_FILE}" ]; then
        # Replace existing empty keys
        sed -i '' "s|^SSH_PRIVATE_KEY_B64=\"\"$|SSH_PRIVATE_KEY_B64=\"${private_key_b64}\"|" "${ENV_FILE}"
        sed -i '' "s|^SSH_PUBLIC_KEY=\"\"$|SSH_PUBLIC_KEY=\"${public_key}\"|" "${ENV_FILE}"
    fi

    # Copy public key to shared folder
    cp "${SANDBOX_DIR}/id_rsa.pub" "${SHARED_DIR}/id_rsa.pub"

    echo "SSH key pair generated and stored in .env."
    echo "‚ö†Ô∏è  IMPORTANT: id_rsa and id_rsa.pub files are in .gitignore and will NOT be committed."
}

#
# Destroys the sandbox environment.
#
burn() {
    echo "Destroying sandbox environment..."
    if utmctl status "${VM_NAME}" | grep -q "running"; then
        utmctl stop "${VM_NAME}"
    fi
    utmctl delete "${VM_NAME}"
    rm -rf "${SHARED_DIR}"
    rm -f "${SANDBOX_DIR}/id_rsa" "${SANDBOX_DIR}/id_rsa.pub"
    echo "Sandbox environment destroyed."
}

#
# Tests the sandbox environment.
#
test_sandbox() {
    echo "Testing sandbox environment..."

    # List all VMs
    utmctl list

    # Check if the VM is registered
    if ! utmctl status "${VM_NAME}" &>/dev/null; then
        echo "Error: VM is not registered. Please create it manually in the UTM app."
        exit 1
    fi

    # Create a test file
    local test_file="${SHARED_DIR}/test_file.txt"
    echo "This is a test file." > "${test_file}"

    # Start the VM
    utmctl start "${VM_NAME}"

    # Wait for the VM to boot and for the SSH port to be open
    echo "Waiting for VM to boot..."
    local i=0
    while ! nc -z localhost 2222 && [ $i -lt 30 ]; do
        sleep 1
        i=$((i+1))
    done

    # Run the analysis script
    ssh -v -i "${SANDBOX_DIR}/id_rsa" -o StrictHostKeyChecking=no -p 2222 root@localhost -- "/media/shared/analyze.sh scan /media/shared/test_file.txt"

    # Stop the VM
    utmctl stop "${VM_NAME}"

    echo "Sandbox environment test complete."
}

#
# Main function
#
main() {
    if [ $# -eq 0 ]; then
        echo "Starting sandbox setup..."
        check_dependencies
        create_directories
        init_env_file
        download_iso
        generate_ssh_key
        echo ""
        echo "‚úÖ Sandbox setup complete!"
        echo ""
        echo "üìù Next steps:"
        echo "   1. Create VM in UTM following SETUP-GUIDE.md"
        echo "   2. Install Alpine Linux in the VM"
        echo "   3. Run ./provision-vm.sh to install analysis tools"
        echo ""
        echo "‚ö†Ô∏è  IMPORTANT: PKI files (id_rsa, id_rsa.pub) are in .gitignore"
        echo "   The single source of truth is .env (also gitignored)"
        exit 0
    fi

    case "$1" in
        burn)
            burn
            ;;
        test)
            test_sandbox
            ;;
        start)
            utmctl start "${VM_NAME}"
            ;;
        *)
            echo "Invalid command: $1"
            exit 1
            ;;
    esac
}

# --- Main execution ---
main "$@"